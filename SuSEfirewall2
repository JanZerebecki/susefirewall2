#!/bin/bash
#
# SuSEfirewall2 - stateful packetfilter rules generator
# Copyright (C) 2000-2002 Marc Heuse <marc@suse.de>
# Copyright (C) 2003,2004 SUSE Linux AG
#
# Author:     Marc Heuse
# Maintainer: Ludwig Nussel
# 
# Please send feedback via http://www.suse.de/feedback
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#
# For all those fellow experts out there: yes I know that this is NOT a 
# firewall setup but a simple (no, not simple, it tries actually to be
# clever) packet filter. But if we would call this "SuSEpacketfilter",
# only a few user would install it, hence general security would be bad.
#
###########################################################################
#                                                                         #
# The configuration file for this firewall script is                      #
# /etc/sysconfig/SuSEfirewall2                                            #
#                                                                         #
# Please make only modifications to this script if you know what you      #
# are doing! A small explanation of the setup can be found in             #
# /usr/share/doc/packages/SuSEfirewall2/README                            #
#                                                                         #
# For new-user help concerning configuring this firewall, take a look at  #
# the configuration file /etc/sysconfig/SuSEfirewall2 - it tells          #
# you all                                                                 #
# (if not: sorry, but configuring a packet filter/screening router is NOT #
# trivial - you must know what you are doing and what it actually does!)  #
#                                                                         #
###########################################################################

help() {
cat <<EOF
SuSEfirewall2 3.3, Copyright (C) 2004  SUSE Linux AG

stateful packet filter rules generator for iptables.

$0 start|test|debug [file FILENAME] [batch]
$0 basic|stop|close|status|help
$0 open ZONE TYPE services...
$0 on|off

Options:
  start	  generate and load the firewall filter rules from 
          /etc/sysconfig/SuSEfirewall2
  stop    unload all filter rules
  close   no incoming network traffic except bootp+ping (for boot security)
  basic   set basic filter rules that drop all incoming access
  test    generate and load the filter rules but do not drop any packet but log
          to syslog anything which *would* be denied
  status  print the output of "iptables -nvL"
  debug   print the iptables command to stdout instead of executing them
  log     show SuSEfirewall2 related syslog messages in a better readable format
  help    this output
  open    open the specified services in the specified zone. You need to
          restart SuSEfirewall2 for changes to take effect.
  on      add SuSEfirwall2 initscripts to boot process and start
  off     remove SuSEfirwall2 initscripts from boot process and stop

  file FILENAME  same as "start" but load alternate config file FILENAME

Calling $0 without any option is the same as the "start" option.
The "file FILENAME" option may be used with the start, test and debug options.
EOF
    exit 0
}

removefiles=()
declare -a  removefiles
removeonexit()
{
    removefiles[${#removefiles[@]}]="$1"
}

cleanup()
{
    local file
    for file in "${removefiles[@]}"; do
	    rm -f "$file"
    done
}
trap cleanup EXIT

syslog()
{
    local pri="-p auth.info"
    [ "$1" -ne 0 ] && pri="-p auth.err"
    shift
    logger -s $pri -t SuSEfirewall2 "$*"
}

warning()
{
    syslog 0 "Warning:" "$*"
}

error()
{
    syslog 0 "Error:" "$*"
}

die()
{
    local ret=1
    trap EXIT
    cleanup
    case "$1" in
	[0-9]) ret="$1"; shift ;;
    esac
    [ -n "$*" ] && syslog "$ret" "$*"
    exit $ret
}

need()
{
    . "$SCRIPTSDIR/SuSEfirewall2-$1"
}

SCRIPTSDIR="/etc/sysconfig/scripts"
FWCONFIG="/etc/sysconfig/SuSEfirewall2"
PERSFWCONFIG="/etc/sysconfig/personal-firewall"
LOCKFILE="/var/lock/SuSEfirewall2.pid"
FW_CUSTOMRULES=""

USE_IPTABLES_BATCH=""

# whether ip6tables supports state matching
IP6TABLES_HAVE_STATE=1

# whether ip6tables support REJECT
IP6TABLES_HAVE_REJECT=1

ACTION="start"
MODE="standard"
INITSCRIPTS="" # on|off
needconfig=
needlock=1

getopttmp=`getopt -o h --long help,scriptsdir:,batch,file:,debug,test \
     -n 'SuSEfirewall2' -- "$@"`

[ $? != 0 ] && die 1 "getopt error"

eval set -- "$getopttmp"

while true ; do
        case "$1" in
		--file) FWCONFIG="$2"; shift 2 ;;
		--batch) USE_IPTABLES_BATCH=1; shift ;;
                --scriptsdir) SCRIPTSDIR="$2" ; shift 2 ;;
                --test) MODE="test" ; shift ;;
                --debug) MODE="debug"; needlock=0 ; shift ;;
                -h|--help) help ; shift ;;
                --) shift ; break ;;
                *) die 1 "getopt error"; ;;
        esac
done

case "$1" in
    start|"") needconfig=1 ;;
    test) MODE="test" ;;
    debug) MODE="debug"; needlock=0 ;;
    easy|novice|basic) ACTION="basic" ;;
    stop|halt|down|shutdown) ACTION="stop"; needconfig=1 ;;
    close) ACTION="close" ;;
    status) ACTION="status"; needlock=0 ;;
    open) ACTION="open"; needlock=0 ;;
    log) ACTION="showlog" ;;
    help) help ;;
    off) ACTION="stop"; needconfig=1; INITSCRIPTS="off" ;;
    on) ACTION="start"; needconfig=1; INITSCRIPTS="on" ;;
    *) help ;;
esac
shift

case "$ACTION" in
    start|stop)
	while [ $# -gt 0 ]; do
	    case "$1" in
		file) FWCONFIG="$2"; shift 2 ;;
		batch) USE_IPTABLES_BATCH=1; shift;;
		force) shift ;;  # unused, for compatability
		*) echo "invalid option: $1"; exit 1 ;;
	    esac
	done
	;;
esac

test -e /etc/sysconfig/network/config && . /etc/sysconfig/network/config

if [ -r "$FWCONFIG" ]; then
    . "$FWCONFIG"
elif [ -n "$needconfig" ]; then
    die 6 " Can not read $FWCONFIG"
fi

if [ -n "$USE_IPTABLES_BATCH" ]; then
    need batch
    check_iptables_batch
fi

### Definitions - fixed
unset ${!LC_*} ${!RC_LC_*} LANGUAGE RC_LANG
export LANG=en_US

export PATH="/sbin:/bin:/usr/sbin:/usr/bin"

modinfo="/sbin/modinfo"
TC="/usr/sbin/tc"
if [ "$MODE" = debug ]; then
    IPTABLES="iptables"
    iptables()
    {
	echo iptables "$@"
    }
    IP6TABLES="ip6tables"
    ip6tables()
    {
	echo ip6tables "$@"
    }
    TC="tc"
    tc()
    {
	echo tc "$@"
    }
    modprobe()
    {
	echo modprobe "$@"
    }
elif [ -n "$USE_IPTABLES_BATCH" ]; then
    IPTABLES=iptables
    IP6TABLES=ip6tables
else
    IPTABLES="/usr/sbin/iptables"
    IP6TABLES="/usr/sbin/ip6tables"

    # Do we have a kernel with IPv6 enabled?
    $IP6TABLES -nvL >/dev/null 2>&1 || IP6TABLES=:
    if ! $IP6TABLES -m state --help >/dev/null 2>&1 || ! $modinfo ip6t_state >/dev/null 2>&1; then
	warning "ip6tables does not support state matching. Extended IPv6 support disabled."
	IP6TABLES_HAVE_STATE=0
    fi
fi
AWK="/bin/awk"
SED="/bin/sed"
IFCONFIG="/sbin/ifconfig"
NETSTAT="/bin/netstat"
SORT="/bin/sort"
LOGGER="/bin/logger"
GREP="/bin/grep"
PERL="/usr/bin/perl"

for i in "$GREP" "$AWK" "$SED" "$IFCONFIG" "$NETSTAT" "$SORT"; do
    if [ ! -x "$i" ]; then
	die 1 "$i is required for SuSEfirewall2 but it is not an executable"
    fi
done

### jump targets
ACCEPT="ACCEPT"
DROP="DROP"
REJECT="reject_func"
[ "$FW_REJECT" = yes ] && DROP="reject_func"

###############

parse_logging()
{
    if [ -z "$FW_LOG_LIMIT" ]; then
	FW_LOG_LIMIT="-m limit --limit 3/minute"
    elif [ "$FW_LOG_LIMIT" = 'no' ]; then
	FW_LOG_LIMIT=''
    else
	FW_LOG_LIMIT="-m limit --limit $FW_LOG_LIMIT"
    fi

    ### logging setup
    if [ -z "$FW_LOG" ]; then
	LOG='--log-level warning --log-tcp-options --log-ip-options --log-prefix SFW2'
    else
	LOG="$FW_LOG"
    fi

    LDC=''  # log drop critical
    LDA=''  # log drop all
    LDAC='' # log drop all or critical
    LAC=''  # log accept critical
    LAA=''  # log accept all
    LAAC='' # log accept all or critical
    LA=''   # log any

    # 'critical' will be unset if 'all' is set since 'critical' might be a special case of 'all'.
    if [ "$FW_LOG_DROP_ALL" != yes ]; then
	LDA=":"
	if [ "$FW_LOG_DROP_CRIT" = no ]; then
	    LDC=":"
	    LDAC=":"
	fi
    else
	LDC=':'
    fi

    if [ "$FW_LOG_ACCEPT_ALL" != yes ]; then
	LAA=":"
	if [ "$FW_LOG_ACCEPT_CRIT" = no ]; then
	    LAC=":"
	    LAAC=":"
	fi
    else 
	LAC=':'
    fi

    # LDA and LDC are : if logging is disabled so check if empty
    [ -z "$LDA" -o -z "$LDC" -o -z "$LDA" -o -z "$LAA" ] || LA=:

    [ "$LAA" = ':' ] && LOG="$FW_LOG_LIMIT $LOG"
}

check_ipv6()
{
    ### ipv6 checks
    case "$FW_IPv6" in
	    drop|reject) IP6TABLES_HAVE_STATE=0 ;;
	    no) IP6TABLES=":" ;;
	    *) FW_IPv6="" ;;
    esac

    $modinfo ip6t_REJECT >/dev/null 2>&1 || IP6TABLES_HAVE_REJECT=0

    if [ \( "$FW_REJECT" = "yes" -o "$FW_IPv6" = "reject" \) \
	-a "$IP6TABLES" != ":" -a "$IP6TABLES_HAVE_REJECT" != 1 ]; then
	    warning "Kernel lacks support for IPv6 REJECT target! Using DROP instead."
	    DROP="DROP"
    fi
}

### Functions
function setproc()
{
    [ -z "$2" -o ! -w "$2" ] && return
    if [ "$MODE" != "debug" ]; then
	echo "$1" > "$2"
    else
	echo "echo \"$1\" > \"$2\""
    fi
}

# parameters: protocol port variable
# check whether $1 and $2 are a valid protocol/port combination and sets global
# variables $proto and $port in iptables syntax
# $2 is used for logging
# returns 1 on error, the content of $proto and $port is undefined then
check_proto_port()
{
    proto="$1"
    port="$2"
    local var="$3"
    case "$proto" in
	'')   error "proto must not be empty in ${var}"; return 1; ;;
	tcp)  [ -n "$port" ] && port="--dport $port"; ;;
	udp)  [ -n "$port" ] && port="--dport $port"; ;;
	icmp) [ -n "$port" ] && port="--icmp-type $port" ;;
	*)
	    if [ -n "$port" ]; then
		error "port is only valid with tcp, udp or icmp in ${var}"
		return 1
	    fi
	;;
    esac
    proto="-p $proto"
    return 0
}

function reset_rules_silent() {
    if [ "$FW_STOP_KEEP_ROUTING_STATE" != "yes" ]; then
	setproc 0 /proc/sys/net/ipv4/ip_forward
    fi
    $IPTABLES -F INPUT
    $IPTABLES -F OUTPUT
    $IPTABLES -F FORWARD
    $IPTABLES -P INPUT ACCEPT
    $IPTABLES -P OUTPUT ACCEPT
    $IPTABLES -P FORWARD ACCEPT
    $IPTABLES -F
    $IPTABLES -X
    $IPTABLES -t nat -F
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -F
    $IPTABLES -t mangle -X

    $IP6TABLES -F INPUT
    $IP6TABLES -F OUTPUT
    $IP6TABLES -F FORWARD
    $IP6TABLES -P INPUT ACCEPT
    $IP6TABLES -P OUTPUT ACCEPT
    $IP6TABLES -P FORWARD ACCEPT
    $IP6TABLES -F
    $IP6TABLES -X
    $IP6TABLES -t mangle -F
    $IP6TABLES -t mangle -X
}

clear_qdisc_settings() {
    local data
    local dev
    local bandwidth
    for data in $FW_HTB_TUNE_DEV; do
        IFS="," read dev bandwidth < <(echo "$data")
        $TC qdisc del dev $dev root 2> /dev/null
    done
}

function reset_rules() {
	reset_rules_silent
        clear_qdisc_settings
}

function load_module()
{
    local i
    for i in "$@"; do
	modprobe "$i"
    done
}

function rulelog()
{
    rule=$1
    case $rule in
	input_*)
		echo IN${rule#input_}
		;;
	forward_*)
		echo FWD${rule#forward_}
		;;
    esac	
}


function allow_basic_related()
{
    for iptables in $IPTABLES $IP6TABLES; do
	$iptables -A OUTPUT -j "$ACCEPT" -m state --state NEW,ESTABLISHED,RELATED
    done
}

function set_basic_rules()
{
    load_module ip_tables ip_conntrack ip_conntrack_ftp ip_nat_ftp ip6table_filter ip6table_mangle
    
    # determine policy
    local DROP_JUMP
    if [ "$DROP" = "ACCEPT" ]; then
	DROP_JUMP="ACCEPT"
    else
	DROP_JUMP="DROP"
    fi
    $IPTABLES -F INPUT
    $IPTABLES -F OUTPUT
    $IPTABLES -F FORWARD
    $IPTABLES -P INPUT "$DROP_JUMP"
    $IPTABLES -P OUTPUT "$DROP_JUMP"
    $IPTABLES -P FORWARD "$DROP_JUMP"
    $IPTABLES -F
    $IPTABLES -X
    # Special REJECT function #
    $IPTABLES -t nat -F
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -F
    $IPTABLES -t mangle -X
    $IPTABLES -N reject_func
    $IPTABLES -A reject_func -p tcp -j REJECT --reject-with tcp-reset
    $IPTABLES -A reject_func -p udp -j REJECT --reject-with icmp-port-unreachable
    $IPTABLES -A reject_func        -j REJECT --reject-with icmp-proto-unreachable

    # loopback is always allowed
    $IPTABLES -A INPUT  -j "$ACCEPT" -i lo
    $IPTABLES -A OUTPUT -j "$ACCEPT" -o lo

    $IP6TABLES -F INPUT
    $IP6TABLES -F OUTPUT
    $IP6TABLES -F FORWARD
    $IP6TABLES -P INPUT "$DROP_JUMP"
    $IP6TABLES -P OUTPUT "$DROP_JUMP"
    $IP6TABLES -P FORWARD "$DROP_JUMP"
    $IP6TABLES -F
    $IP6TABLES -X
    # Special REJECT function #
    $IP6TABLES -t mangle -F
    $IP6TABLES -t mangle -X
    $IP6TABLES -N reject_func
    if [ "$IP6TABLES_HAVE_REJECT" != 1 ]; then
	$IP6TABLES -A reject_func -j DROP
    else
	$IP6TABLES -A reject_func -p tcp -j REJECT --reject-with tcp-reset
	$IP6TABLES -A reject_func -p udp -j REJECT --reject-with port-unreach
	$IP6TABLES -A reject_func        -j REJECT --reject-with addr-unreach # know anything better?
    fi

    # loopback is always allowed
    $IP6TABLES -A INPUT  -j "$ACCEPT" -i lo
    $IP6TABLES -A OUTPUT -j "$ACCEPT" -o lo

    # workaround for ip6tables without state matching
    if [ "$IP6TABLES_HAVE_STATE" != 1 ]; then
	# Drop all until IPv6 is really supported
	$LDA $IP6TABLES -A INPUT -j LOG ${LOG}"-IN-IPv6_PROHIB "
	if [ "$FW_IPv6" = "drop" -o "$IP6TABLES_HAVE_REJECT" != 1 ]; then
	    $IP6TABLES -A INPUT -j "$DROP"
	else
	    $IP6TABLES -A INPUT -j "$REJECT"
	fi
	if [ "$IP6TABLES_HAVE_REJECT" != 1 -o "$FW_IPv6_REJECT_OUTGOING" != "yes" ]; then
	    $IP6TABLES -A OUTPUT -j "$DROP"
	else
	    $IP6TABLES -A OUTPUT -j "$REJECT"
	fi
	IP6TABLES=":" # disable further rules
    fi

    # needed for dhcp and dns replies
    local iptables
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	    $LAA $iptables -A INPUT -j LOG ${LOG}"-IN-ACC-RELATED " -m state --state RELATED -p tcp
	    $LAA $iptables -A INPUT -j LOG ${LOG}"-IN-ACC-RELATED " -m state --state RELATED -p udp
	    $iptables -A INPUT -j "$ACCEPT" -m state --state ESTABLISHED,RELATED -p tcp
	    $iptables -A INPUT -j "$ACCEPT" -m state --state ESTABLISHED,RELATED -p udp

	    # if two hosts have a tcp connection on fixed ports and
	    # one of the hosts crashes it will send a SYN to the
	    # peer if it comes back up. The peer sends back ACK as
	    # it thinks there is already a connection established.
	    # This ACK is INVALID and must be answered with RST
	    # otherwise long timeouts may occur (#46818).
	    $LDA $iptables -A INPUT -j LOG ${LOG}"-IN-REJECT-ACK " -m state --state INVALID -p tcp --tcp-flags SYN,RST,ACK ACK
	    $iptables -A INPUT -j "$REJECT" -m state --state INVALID -p tcp --tcp-flags SYN,RST,ACK ACK
    done
}

handle_initscripts()
{
    local i
    case "$INITSCRIPTS" in
	on)
	    for i in SuSEfirewall2_init SuSEfirewall2_setup SuSEfirewall2_final; do
		/sbin/insserv -f $i
	    done
	    ;;
	off)
	    for i in SuSEfirewall2_final SuSEfirewall2_setup SuSEfirewall2_init; do
		/sbin/insserv -r -f $i
	    done
	    ;;
    esac
}

# $1 protocol
# $2 port
# $3 type
#
# Where type can be any of
#  Minimize-Delay 16 (0x10)
#  Maximize-Throughput 8 (0x08)
#  Maximize-Reliability 4 (0x04)
#  Minimize-Cost 2 (0x02)
#  Normal-Service 0 (0x00)
set_tos()
{
    local i
    local tables="OUTPUT"

    [ "$FW_ROUTE" = yes ] && tables="OUTPUT PREROUTING"

    for i in $tables; do
	$IPTABLES -A $i -j TOS -t mangle -p "$1" --sport "$2" --set-tos "$3"
	$IPTABLES -A $i -j TOS -t mangle -p "$1" --dport "$2" --set-tos "$3"
    done
}

apply_tos_settings() {
    set_tos tcp  20 Maximize-Throughput # FTP Data
    set_tos tcp  80 Maximize-Throughput # HTTP
    set_tos tcp  53 Minimize-Delay # DNS
    set_tos udp  53 Minimize-Delay # DNS
    set_tos udp 161 Maximize-Reliability # SNMP
    set_tos udp 162 Maximize-Reliability # SNMP Trap
    set_tos udp 514 Maximize-Reliability # Syslog
}

# set $ip and $net to list of ips and ip/prefix separated by space. set $dev to actual name of device
getdevinfo()
{
    ip=
    net=
    dev=`getcfg-interface "$1"`
    if [ "$?" -ne 0 -o -z "$dev" ]; then
	dev=""
	return 1
    fi

    while read -a a; do
	set -- "${a[@]}"

	while [ $# -gt 0 ]; do
	    if [ "$1" = "inet" ]; then
		ip="$ip ${2%%/*}"
		net="$net $2"
		break
	    else
		shift
	    fi
	done
    done < <(ip -o -4 addr show dev $dev 2>/dev/null)

    return 0
}

#
# tune the upload stream a little bit
# with DSL for example, you have the problem, that your
# downstream collapses if your upstream is full.
# After this tuning this should not happen anymore.
# interactive SSH and VPN are faster too, because they
# get some extra bandwidth besides the bulk traffic
#
# variabel from sysconfig:
#   FW_HTB_TUNE_DEV="DEV1,BANDWIDTH1 DEV2,BANDWIDTH2 ..."
#
# any questions about this to uwe.gansert@suse.de
#
do_qdisc_settings() {
    if [ -n "$FW_HTB_TUNE_DEV" ]; then
	modprobe sch_htb 2> /dev/null
    fi
    clear_qdisc_settings
    for DEVICE_DATA in $FW_HTB_TUNE_DEV; do
        IFS="," read DEV BANDWIDTH < <(echo "$DEVICE_DATA")

	getdevinfo "$DEV"
	DEV="$dev"

        # sanity check
        if [ -n "$DEV" -a -n "$BANDWIDTH" ]; then
            # reserve about 15% for small packets (TCP ACK),
            # interactive SSH from and to us and DNS querys.
            # We don't need too much bandwidth but we need it fast.
            SMALL_PACKET_BW=$(( $BANDWIDTH / 7 ))
            if [ "$SMALL_PACKET_BW" -eq 0 ]; then
                warning "illegal bandwidth settings for $DEV in FW_HTB_TUNE_DEV"
            fi

            # reserve 25% for VPN traffic. Never mind if we don't have
            # a VPN. No bandwidth will be wasted
            VPN_BW=$(( $BANDWIDTH / 4 ))
            if [ "$VPN_BW" -eq 0 ];then
                warning "illegal bandwidth settings for $DEV in FW_HTB_TUNE_DEV"
            fi

            # bulk traffic
            REST_BW=$(( ${BANDWIDTH}-${SMALL_PACKET_BW}-${VPN_BW} ))

            $TC qdisc add dev $DEV root handle 1:0 htb default 20       # adding the queing discipline

	    # adding the root class 1:1
            $TC class add dev $DEV parent 1:0 classid 1:1 htb \
                rate ${BANDWIDTH}kbit ceil ${BANDWIDTH}kbit

            # class for small tcp packets 1:10
            $TC class add dev $DEV parent 1:1 classid 1:10 htb \
                rate ${SMALL_PACKET_BW}kbit ceil ${BANDWIDTH}kbit prio 0 quantum 3000 # and interactive SSH
	    # class for VPN traffic       1:11
            $TC class add dev $DEV parent 1:1 classid 1:11 htb \
                rate ${VPN_BW}kbit ceil ${BANDWIDTH}kbit prio 1 quantum 3000
	    # class for all the rest      1:20
            $TC class add dev $DEV parent 1:1 classid 1:20 htb \
                rate ${REST_BW}kbit ceil ${BANDWIDTH}kbit prio 2 quantum 3000
	    # packets, marked with "10" to queue 1:10
            $TC filter add dev $DEV parent 1:0 prio 0 protocol ip \
                handle 10 fw flowid 1:10
	    # packets, marked with "11" to queue 1:11
            $TC filter add dev $DEV parent 1:0 prio 1 protocol ip \
                handle 11 fw flowid 1:11

	    # iptables marks small TCP packets (potentially ACK)
	    # with 10, so "tc" will send them to queue 1:10
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p tcp \
                      -m length --length :64 -j MARK --set-mark 10

	    # iptables marks SSH interactive ssh traffic
	    # with 10 too. So it gets to queue 1:10 like
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p tcp \
                      -m tos --tos Minimize-Delay \
                      -m tcp --dport 22 -j MARK --set-mark 10

	    # like the rule above, but this time we are
	    # the sshd and want to respond fast, even when
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p tcp \
                      -m tos --tos Minimize-Delay \
                      -m tcp --sport 22 -j MARK --set-mark 10 

            # same like above for DNS
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p udp \
                      -m udp --dport 53 -j MARK --set-mark 10
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p tcp \
                      -m tcp --dport 53 -j MARK --set-mark 10

	    # iptables marks VPN traffic with 11
	    # if we don't have VPN, never mind, no bandwidth
	    # will be wastet and if we need more, then it'll be
	    # be "borrowed" from the other queues
            $IPTABLES -A POSTROUTING -t mangle -o $DEV -p 50 \
                      -j MARK --set-mark 11
 
        else
            warning "illegal settings in FW_HTB_TUNE_DEV=\"$FW_HTB_TUNE_DEV\", skipped device \"$DEV\""
        fi
    done
}

ifacenotactive() {
    test -z "$DEV" || {
	case "$DEV" in
	    *ppp*) ;;
	    *) warning "interface $DEV is not active."
		 ;;
	esac
    }
}

# find interface name for hardware description
function getcfg-interface()
{
    if [ -x /sbin/getcfg-interface ]; then
	/sbin/getcfg-interface "$1" || echo "$1"
    else
	echo "$1"
    fi
}


auto_detect_done=0
auto_detect_interfaces()
{
    [ "$auto_detect_done" = 1 ] && return
    local zone
    while read line; do
	set -- $line
	zone="$1"
	shift
	case "$zone" in
	    External:)
		FW_DEV_EXT_AUTO="$*"
	    ;;
	    Internal:)
		FW_DEV_INT_AUTO="$*"
	    ;;
	esac
    done < <(/bin/bash $SCRIPTSDIR/SuSEfirewall2-autointerface.sh)
    auto_detect_done=1
}

# auto interface detection
auto_detect_all_interfaces()
{
    if [ "$FW_DEV_EXT" = "auto" ]; then
	auto_detect_interfaces
	FW_DEV_EXT="$FW_DEV_EXT_AUTO"
    fi

    if [ "$FW_DEV_INT" = "auto" ]; then
	auto_detect_interfaces
	FW_DEV_INT="$FW_DEV_INT_AUTO"
    fi

    if [ "$FW_MASQ_DEV" = "auto" ]; then
	FW_MASQ_DEV="$FW_DEV_EXT"
    fi
}

setlock()
{
    ### Locking mechanism
    if [ "$needlock" -ne 0 ]; then
	if [ -e "$LOCKFILE" ]; then
	    read PID < $LOCKFILE
	    syslog 0 "Another SuSEfirewall2 with PID $PID found, waiting ..."
	    i=0
	    while [ -e "$LOCKFILE" -a "$i" -lt 15 ]; do
		sleep 2
		i=$(( i + 1 ))
	    done
	    if [ -e "$LOCKFILE" ]; then
		syslog 0 "Lockfile is still there, ignoring it ..."
		kill -TERM $PID
		sleep 2
		kill -KILL $PID
		rm -f "$LOCKFILE"
	    fi
	fi
	removeonexit "$LOCKFILE"
	set -o noclobber
	echo "$$" > $LOCKFILE || exit 1
	set +o noclobber
    fi
}

##
## function definitions for full featured mode
##

# Provide empty functions for transparent hook support for customised rules
fw_custom_before_antispoofing() { true; }
fw_custom_after_antispoofing() { true; }
fw_custom_before_port_handling() { true; }
fw_custom_before_masq() { true; }
fw_custom_before_denyall() { true; }

evaluateinterfaces()
{
    devs=""
    dev_any=""
    ips=""
    nets=""
    local dev
    for dev in "$@" ; do
	if [ "$dev" = "any" ]; then
	    dev_any="yes"
	    continue
	fi
	getdevinfo "$dev" || continue
	case "$dev" in *:*) continue; ;; esac

	[ -z "$ip" ] && { ifacenotactive; continue; }

	ips="$ips $ip"
	nets="$nets $net"
	devs="$devs $dev"
    done
}

parse_interfaces()
{
    evaluateinterfaces $FW_DEV_INT
    FW_DEV_INT="$devs"
    DEV_INT="$ips"
    DEV_INT_NET="$nets"

    evaluateinterfaces $FW_DEV_DMZ
    FW_DEV_DMZ="$devs"
    DEV_DMZ="$ips"
    DEV_DMZ_NET="$nets"

    evaluateinterfaces $FW_DEV_EXT
    FW_DEV_EXT="$devs"
    DEV_EXT_ANY="$dev_any"
    DEV_EXT="$ips"
    DEV_EXT_NET="$nets"

    evaluateinterfaces $FW_MASQ_DEV
    FW_MASQ_DEV="$devs"
}

load_customrules()
{
    ### Load custom rules
    if [ -n "$FW_CUSTOMRULES" ]; then
	if [ ! -r "$FW_CUSTOMRULES" ]; then
	    die 1 "Firewall customary rules file can not be read from $FW_CUSTOMRULES"
	fi
	. "$FW_CUSTOMRULES"
	syslog 0 "Firewall customary rules loaded from $FW_CUSTOMRULES"
    fi
}

check_interfaces()
{
    set -- $DEV_EXT $DEV_INT $DEV_DMZ
    test -z "$1" && warning 'no interface active'

    set -- $DEV_EXT
    test -z "$1" && { DEV_EXT=""; DEV_EXT_NET=""; }

    set -- $DEV_INT
    test -z "$1" && { DEV_INT=""; DEV_EXT_INT=""; }

    set -- $DEV_DMZ
    test -z "$1" && { DEV_DMZ=""; DEV_EXT_DMZ=""; }
}

verify_parameters()
{
    if [ "$FW_ROUTE" = no ]; then
	if [ "$FW_MASQUERADE" = yes ]; then
	    warning 'FW_ROUTE needs to be set to yes for masquerading to work!'
	fi
	if [ "$FW_ALLOW_CLASS_ROUTING" = yes ]; then
	    warning 'FW_ROUTE needs to be set to yes for FW_ALLOW_CLASS_ROUTING to work!'
	fi
	if [ "$FW_ALLOW_PING_DMZ" = yes -o "$FW_ALLOW_PING_EXT" = yes ]; then
	    warning 'FW_ROUTE needs to be set to yes for FW_ALLOW_PING_EXT and/or FW_ALLOW_PING_DMZ to work!'
	fi
    fi

    if [ "$FW_MASQUERADE" = no ]; then
	[ -n "$FW_MASQ_NETS" ] && warning 'FW_MASQ_NETS needs FW_MASQUERADE set to yes to work!'
	[ -n "$FW_FORWARD_MASQ" ] && warning 'FW_FORWARD_MASQ needs FW_MASQUERADE set to yes to work!'
    fi
}

# Turn ip forwarding on if configured
switch_on_ip_forwarding()
{
    if [ "$FW_ROUTE" = yes ]; then
	setproc 1 /proc/sys/net/ipv4/ip_forward
    else
	setproc 0 /proc/sys/net/ipv4/ip_forward
    fi
}

# warn user if device to masquerade is  from a non private network,
# add the net to DEV_MASQ_NET which is used for anti-spoof later.
# 0/0 has to be skipped here, otherwise the spoof rules would block
# anything
verify_masq_nets()
{
    local nets net1
    for nets in $FW_MASQ_NETS ; do
	IFS=, eval set -- \$nets
	net1="$1"

	# skip 0/0
	test "$net1" = "0/0" && continue

	IFS=/ eval set -- \$net1

	[ -z "$2" ] && continue

	case "$1" in
	    10.*|172.1[6789].*|172.2[0-9].*|172.3[01].*|192.168.*) ;;
	    *) warning "The network $net1 you want to masquerade is not from a private network " \
		    'like 10.0.0.0/8, 172.16.0.0/12 or 192.168.0.0/16'
	esac

	DEV_MASQ_NET="$DEV_MASQ_NET $net1"
    done
}

#################################
# Configuring more kernel stuff #
#################################
set_proc_stuff()
{
    setproc 1 /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 
# test "$FW_ALLOW_PING_FW" = yes || setproc 1 /proc/sys/net/ipv4/icmp_echo_ignore_all  # XXX
    setproc 1 /proc/sys/net/ipv4/tcp_syncookies 
    setproc 1 /proc/sys/net/ipv4/ip_always_defrag  # XXX not there?
    setproc 0 /proc/sys/net/ipv4/tcp_ecn 
    for i in /proc/sys/net/ipv4/conf/*; do
	setproc 0 $i/accept_redirects 
	setproc 0 $i/accept_source_route 
	setproc 1 $i/rp_filter 
	#setproc 0 $i/mc_forwarding test -w says ok but its ro
    done
    if [ "$FW_KERNEL_SECURITY" != no ]; then
	setproc 1 /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses 
	setproc 5 /proc/sys/net/ipv4/icmp_echoreply_rate 
	setproc 5 /proc/sys/net/ipv4/icmp_destunreach_rate 
	setproc 5 /proc/sys/net/ipv4/icmp_paramprob_rate 
	setproc 6 /proc/sys/net/ipv4/icmp_timeexceed_rate 
	setproc 20 /proc/sys/net/ipv4/ipfrag_time 
	setproc 1 /proc/sys/net/ipv4/igmp_max_memberships 
	setproc "1024 29999" /proc/sys/net/ipv4/ip_local_port_range 
	for i in /proc/sys/net/ipv4/conf/*; do
	    setproc 1 $i/log_martians 
	    setproc 0 $i/bootp_relay 
	    [ "$FW_ROUTE" != yes ] && setproc 0 $i/forwarding
	    setproc 0 $i/proxy_arp 
	    setproc 1 $i/secure_redirects 
	done
	setproc 1 /proc/sys/net/ipv4/route/flush
    fi
}

# Make input/forward chains
create_chains()
{
    local iptables
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	for TARGET in input forward; do
	    for CHAIN in ext dmz int; do
		$iptables -N ${TARGET}_${CHAIN}
	    done
	done
    done
}

antispoof_generic()
{
    # Anti Spoofing rules - not interface dependent #
    if [ "$FW_ANTISPOOF" = yes ]; then
	$LDAC $IPTABLES -A INPUT -j LOG ${LOG}"-IN-DROP-ANTISPOOF "  -s 127.0.0.0/8
	$LDAC $IPTABLES -A INPUT -j LOG ${LOG}"-IN-DROP-ANTISPOOF "  -d 127.0.0.0/8
	$IPTABLES -A INPUT -j "$DROP" -s 127.0.0.0/8
	$IPTABLES -A INPUT -j "$DROP" -d 127.0.0.0/8
	for SPOOF in $DEV_INT $DEV_EXT $DEV_DMZ; do
	    $LDAC $IPTABLES -A INPUT -j LOG ${LOG}"-IN-DROP-ANTISPOOF "  -s $SPOOF
	    $IPTABLES -A INPUT -j "$DROP" -s $SPOOF
	done
    fi
}

### handling of broadcasts ###
parse_broadcast()
{
    local tmp=""
    FW_ALLOW_BROADCAST_int=no
    FW_ALLOW_BROADCAST_ext=no
    FW_ALLOW_BROADCAST_dmz=no
    for i in $FW_ALLOW_FW_BROADCAST; do
	case $i in
	    yes) FW_ALLOW_BROADCAST_int=yes; FW_ALLOW_BROADCAST_ext=yes; FW_ALLOW_BROADCAST_dmz=yes ;;
	    int) FW_ALLOW_BROADCAST_int=yes ;;
	    ext) FW_ALLOW_BROADCAST_ext=yes ;;
	    dmz) FW_ALLOW_BROADCAST_dmz=yes ;;
	    no) ;;
	    *) tmp="$tmp $i"
	esac
    done
    FW_ALLOW_FW_BROADCAST="$tmp"

    [ -z "$FW_IGNORE_FW_BROADCAST" ] && FW_IGNORE_FW_BROADCAST="ext";
    FW_IGNORE_BROADCAST_int=no
    FW_IGNORE_BROADCAST_ext=no
    FW_IGNORE_BROADCAST_dmz=no
    tmp=""
    for i in $FW_IGNORE_FW_BROADCAST; do
	case $i in
	    yes) FW_IGNORE_BROADCAST_int=yes; FW_IGNORE_BROADCAST_ext=yes; FW_IGNORE_BROADCAST_dmz=yes ;;
	    int) FW_IGNORE_BROADCAST_int=yes ;;
	    ext) FW_IGNORE_BROADCAST_ext=yes ;;
	    dmz) FW_IGNORE_BROADCAST_dmz=yes ;;
	    no) ;;
	    *) tmp="$tmp $i"
	esac
    done
    FW_IGNORE_FW_BROADCAST="$tmp"
}

drop_broadcast()
{
    local zone="$1"
    local allow
    local ignore
    local port

    eval allow="\$FW_ALLOW_BROADCAST_$zone"
    eval ignore="\$FW_IGNORE_BROADCAST_$zone"

    [ "$allow" = yes ] && return
    
    local match="-A input_$zone -m pkttype --pkt-type broadcast"

    for port in $FW_ALLOW_FW_BROADCAST; do
	$LAA $IPTABLES $match -p udp --dport $port -j LOG ${LOG}"-ACC-BCAST${zone:0:1} "
	$IPTABLES $match -p udp --dport $port -j "$ACCEPT"
    done
    for port in $FW_IGNORE_FW_BROADCAST; do
	$IPTABLES $match -p udp --dport $port -j DROP
    done

    if [ "$ignore" != yes ]; then
	$LDA $IPTABLES $match -j LOG ${LOG}"-DROP-BCAST${zone:0:1} "
    fi

    $IPTABLES $match -j DROP # no need to send icmp for broadcasts
}

### IPsec ###

allow_ipsec()
{
    ipsec_chain=""
    case "$FW_IPSEC_TRUST" in
	yes|int) ipsec_chain=int ;;
	ext) ipsec_chain=ext ;;
	dmz) ipsec_chain=dmz ;;
    esac

    IPSEC_MATCH=
    if [ -n "$ipsec_chain" ]; then
	IPSEC_MATCH="-m policy --dir in --pol ipsec --proto esp"
	$IPTABLES -A INPUT -j "input_$ipsec_chain" $IPSEC_MATCH
	$IPTABLES -A FORWARD -j "forward_$ipsec_chain" $IPSEC_MATCH
    fi
}

#####################################
# Rule split up - forking to chains #
#####################################
# ipv4 and ipv6
fork_to_chains()
{
    local iptables
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	for DEV in $FW_DEV_EXT; do
	    $iptables -A INPUT -j input_ext -i $DEV
	    test "$FW_ROUTE" = yes && $iptables -A FORWARD -j forward_ext -i $DEV
	done
	for DEV in $FW_DEV_DMZ; do
	    $iptables -A INPUT -j input_dmz -i $DEV
	    test "$FW_ROUTE" = yes && $iptables -A FORWARD -j forward_dmz -i $DEV
	done
	for DEV in $FW_DEV_INT; do
	    $iptables -A INPUT -j input_int -i $DEV
	    test "$FW_ROUTE" = yes && $iptables -A FORWARD -j forward_int -i $DEV
	done
	if [ "$DEV_EXT_ANY" = 'yes' ]; then
	    $iptables -A INPUT -j input_ext
	fi
    done
}

# ipv4 and ipv6
finish_chains()
{
    local iptables
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	# anything which is now not in the input_* chains is evil
	$LDAC $iptables -A INPUT -j LOG ${LOG}"-IN-ILL-TARGET " 
	$iptables -A INPUT -j "$DROP"

	if [ "$FW_ROUTE" = yes ]; then
	    $LDAC $iptables -A FORWARD -j LOG ${LOG}"-FWD-ILL-ROUTING "
	    $iptables -A FORWARD -j "$DROP" # this is an unneeded rule, but looks nice :)
	fi

	# MSS stuff needs this?
	if [ "$FW_ROUTE" = yes ]; then
	    $IPTABLES -I FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
	fi

	$iptables -A OUTPUT -j ACCEPT -m state --state NEW,ESTABLISHED,RELATED
	$iptables -A OUTPUT -j LOG ${LOG}"-OUT-ERROR " 
    done
}

# anti ip spoofing rules
antispoof_per_interface()
{
    [ "$FW_ANTISPOOF" != yes ] && return

    ################################################################
    # Anti Spoofing/Circumvention protection - interface dependent #
    ################################################################
    for DEV in $FW_DEV_INT; do
	for IP in $DEV_EXT; do
	    $IPTABLES -A input_int -j LOG ${LOG}"-IN-ACC_DENIED_INT "  -i $DEV -d $IP
	    $IPTABLES -A input_int -i $DEV -d $IP -j "$DROP"
	done
    done
    # anti spoof internal
    for SPOOF in $DEV_EXT_NET $DEV_DMZ_NET; do
	# special case for internal ipsec devices that have the same ip as the
	# external device
	for net in $DEV_INT_NET; do
	    if [ "$net" = "$SPOOF" ]; then
		echo "$net is internal and external, no spoof protection possible from internal"
		continue 2
	    fi
	done

	$LDC $IPTABLES -A input_int -j LOG ${LOG}"-INint-DROP-ANTISPOOF " -s $SPOOF
	$IPTABLES -A input_int -j "$DROP" -s $SPOOF
	if [ "$FW_ROUTE" = yes ]; then
	    $LDC $IPTABLES -A forward_int -j LOG ${LOG}"-FWDint-DROP-ANTISPOOF " -s $SPOOF
	    $IPTABLES -A forward_int -j "$DROP" -s $SPOOF
	fi
    done
    # anti spoof dmz
    for SPOOF in $DEV_EXT_NET $DEV_INT_NET; do
	$LDC $IPTABLES -A input_dmz -j LOG ${LOG}"-INdmz-DROP-ANTISPOOF " -s $SPOOF
	$IPTABLES -A input_dmz -j "$DROP" -s $SPOOF
	if [ "$FW_ROUTE" = yes ]; then
	    $LDC $IPTABLES -A forward_dmz -j LOG ${LOG}"-FWDdmz-DROP-ANTISPOOF " -s $SPOOF
	    $IPTABLES -A forward_dmz -j "$DROP" -s $SPOOF
	fi
    done
    # anti spoof external
    for SPOOF in $DEV_INT_NET $DEV_DMZ_NET $DEV_MASQ_NET; do
	# special case for internal ipsec devices that have the same ip as the
	# external device
	for net in $DEV_EXT_NET; do
	    if [ "$net" = "$SPOOF" ]; then
		echo "$net is internal and external, no spoof protection possible from external"
		continue 2
	    fi
	done
	$LDC $IPTABLES -A input_ext -j LOG ${LOG}"-INext-DROP-ANTISPOOF " -s $SPOOF
	$IPTABLES -A input_ext -j "$DROP" -s $SPOOF
	if [ "$FW_ROUTE" = yes ]; then
	    $LDC $IPTABLES -A forward_ext -j LOG ${LOG}"-FWDext-DROP-ANTISPOOF " -s $SPOOF
	    $IPTABLES -A forward_ext -j "$DROP" -s $SPOOF
	fi
    done
}

# Protect the firewall from the internal network? #
protect_from_internal()
{
    [ "$FW_PROTECT_FROM_INTERNAL" != no ] && return

    local iptables
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	$LAA $iptables -A input_int -j LOG ${LOG}"-INint-ACC-ALL-INT " 
	$iptables -A input_int -j "$ACCEPT"
    done
}

# ICMP stuff
allow_icmp()
{
    local chain dev itype
    # INPUT ICMP rules
    if [ "$FW_ALLOW_FW_SOURCEQUENCH" != "no" ]; then
	for chain in input_ext input_dmz input_int; do
	    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-INext-ACC-SOURCEQUENCH "  -p icmp --icmp-type source-quench
	    $IPTABLES -A $chain -j "$ACCEPT" -p icmp --icmp-type source-quench
	done
    fi

    if [ "$FW_ALLOW_PING_FW" = yes ]; then
	for chain in input_ext input_dmz input_int; do
	    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmp --icmp-type echo-request
	    $IPTABLES -A $chain -j "$ACCEPT" -p icmp --icmp-type echo-request

	    $LAA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmpv6 --icmpv6-type echo-request
	    $IP6TABLES -A $chain -j "$ACCEPT" -p icmpv6 --icmpv6-type echo-request
	done
    fi
    local icmp_types="echo-reply destination-unreachable time-exceeded parameter-problem timestamp-reply address-mask-reply"
    for itype in $icmp_types; do
	for chain in input_ext input_dmz input_int; do
	    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-ICMP "  -m state --state ESTABLISHED,RELATED -p icmp --icmp-type $itype
	    $IPTABLES -A $chain -j "$ACCEPT" -m state --state ESTABLISHED,RELATED -p icmp --icmp-type $itype
	done
    done
    icmp_types="echo-reply destination-unreachable time-exceeded parameter-problem"
    for itype in $icmp_types; do
	for chain in input_ext input_dmz input_int; do
	    $LAA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-ICMP " -m state --state ESTABLISHED,RELATED  -p icmpv6 --icmpv6-type $itype
	    $IP6TABLES -A $chain -j "$ACCEPT" -m state --state ESTABLISHED,RELATED -p icmpv6 --icmpv6-type $itype
	done
    done
    # DROP rules for input ICMP are after trusted handling (see below)
    
    # state matching for these seems to be broken
    icmp_types="router-solicitation router-advertisement neighbour-solicitation neighbour-advertisement"
    for itype in $icmp_types; do
	for chain in input_ext input_dmz input_int; do
	    $LAA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-ICMP " -p icmpv6 --icmpv6-type $itype
	    $IP6TABLES -A $chain -j "$ACCEPT" -p icmpv6 --icmpv6-type $itype
	done
    done

    # OUTPUT ICMP rules
    $LA $IPTABLES -A OUTPUT -j LOG ${LOG}"-OUT-TRACERT-ATTEMPT "  -p icmp --icmp-type time-exceeded
    if [ "$FW_ALLOW_FW_TRACEROUTE" = "yes" ]; then
	$IPTABLES -A OUTPUT -j "$ACCEPT" -p icmp --icmp-type time-exceeded
	$IPTABLES -A OUTPUT -j "$ACCEPT" -p icmp --icmp-type port-unreachable
    else
	$IPTABLES -A OUTPUT -j "$DROP" -p icmp --icmp-type time-exceeded
	$IP6TABLES -A OUTPUT -j "$DROP" -p icmpv6 --icmpv6-type time-exceeded
    fi

# XXX what about other types?
    for itype in fragmentation-needed network-prohibited host-prohibited communication-prohibited; do
	$IPTABLES -A OUTPUT -j "$ACCEPT" -p icmp --icmp-type $itype
    done
    $IPTABLES -A OUTPUT -j "$DROP" -p icmp --icmp-type destination-unreachable # we deny all other icmp type 3 codes
    
# XXX hmm, maybe additional restrictions here like for IPv4?
    $LAA $IP6TABLES -A OUTPUT -j LOG ${LOG}"-OUT-ICMP " -p icmpv6
    $IP6TABLES -A OUTPUT -j "$ACCEPT" -p icmpv6

    # FORWARD ICMP rules
    if [ "$FW_ROUTE" = "yes" ]; then
	if [ "$FW_ALLOW_PING_DMZ" = yes ]; then
	    for dev in $FW_DEV_DMZ; do
		for chain in forward_ext forward_int; do
		    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmp --icmp-type echo-request -o $dev
		    $IPTABLES -A $chain -j "$ACCEPT" -m state --state NEW -p icmp --icmp-type echo-request -o $dev
		    $LAA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmpv6 --icmpv6-type echo-request -o $dev
		    $IP6TABLES -A $chain -j "$ACCEPT" -m state --state NEW -p icmpv6 --icmpv6-type echo-request -o $dev
		done
	    done
	    $LAA $IPTABLES -A forward_dmz -j LOG ${LOG}"-FWDdmz-ACC-PING "  -p icmp --icmp-type echo-reply
	    $IPTABLES -A forward_dmz -j "$ACCEPT"  -m state --state ESTABLISHED -p icmp --icmp-type echo-reply
	    $LAA $IP6TABLES -A forward_dmz -j LOG ${LOG}"-FWDdmz-ACC-PING "  -p icmpv6 --icmpv6-type echo-reply
	    $IP6TABLES -A forward_dmz -j "$ACCEPT"  -m state --state ESTABLISHED -p icmpv6 --icmpv6-type echo-reply
	fi
	if [ "$FW_ALLOW_PING_EXT" = yes ]; then
	    for dev in $FW_DEV_EXT; do
		for chain in forward_int forward_dmz; do
		    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmp --icmp-type echo-request -o $dev
		    $IPTABLES -A $chain -j "$ACCEPT" -m state --state NEW -p icmp --icmp-type echo-request -o $dev
		    $LAA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-PING "  -p icmpv6 --icmpv6-type echo-request -o $dev
		    $IP6TABLES -A $chain -j "$ACCEPT" -m state --state NEW -p icmpv6 --icmpv6-type echo-request -o $dev
		done
	    done
	    $LAA $IPTABLES -A forward_ext -j LOG ${LOG}"-FWDext-ACC-PING "  -p icmp --icmp-type echo-reply
	    $IPTABLES -A forward_ext -j "$ACCEPT"  -m state --state ESTABLISHED -p icmp --icmp-type echo-reply
	    $LAA $IP6TABLES -A forward_ext -j LOG ${LOG}"-FWDext-ACC-PING "  -p icmpv6 --icmpv6-type echo-reply
	    $IP6TABLES -A forward_ext -j "$ACCEPT"  -m state --state ESTABLISHED -p icmpv6 --icmpv6-type echo-reply
	fi
    fi
    # drop rule for forwarding chains are at the end of the forwarding rules
}

#############################
# Trusted Networks Handling #
#############################
process_trusted_nets()
{
    local nets net chain
    for nets in $FW_TRUSTED_NETS; do
	IFS=, eval set -- \$nets
	net="$1"
	proto="$2"
	port="$3"
	if [ -n "$4" ]; then
	    error "Too many arguments in FW_TRUSTED_NETS -> $nets"
	elif [ -z "$net" ]; then
	    error "network parameter of FW_TRUSTED_NETS is empty -> $nets"
	elif check_proto_port "$proto" "$port" 'FW_TRUSTED_NETS'; then
	    for chain in input_ext input_dmz input_int; do # trusted networks can be on any interface ...
		$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-TRUST " -m state --state NEW -s $net $proto $port
		$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-TRUST " -s $net $proto $port
		$IPTABLES -A $chain -j "$ACCEPT"  -m state --state NEW,ESTABLISHED,RELATED -s $net $proto $port
	    done
	fi
    done
}

# determine port numbers of rpc services and generate a suitable iptables
# parameter fragment
#
# parameters: names of rpc services, e.g. ypbind mountd
rpcservicerules()
{
	[ -z "$1" ] && return
	$PERL "$SCRIPTSDIR/SuSEfirewall2-rpcinfo" "$@"
}

# parameters: int|ext|dmz REJECT|DROP INT|EXT|DMZ
reject_or_drop_services()
{
    local chain="input_$1"
    local action="$2"
    local var="FW_SERVICES_${action}_$3"
    local services target service proto net port
    local iptables

    eval target=\$$action
    eval services=\"\$$var\"

    for service in $services; do
	IFS=, eval set -- \$service
	if [ "$#" -ne 3 ]; then
	    error "too few parameters in $var -> $service"
	    continue
	fi

	net="${1:-0/0}"
	iptables="$IPTABLES $IP6TABLES"
	case "$net" in
	    *:*) iptables="$IP6TABLES" ;;
	    [0-9]*.*.*.*) iptables="$IPTABLES" ;;
	esac

	if check_proto_port "$2" "$3" "$var"; then
	    for iptables in $iptables; do
		$LDA $iptables -A $chain -s $net $proto $port -m state --state NEW -j LOG ${LOG}"-`rulelog $chain`-$action "
		$iptables -A $chain -s $net $proto $port -m state --state NEW -j "$target"
	    done
	fi
    done
}

# some words about the autoprotecting feature below: these long lines of code
# try to identify which services were allowed via the config file (including
# the DNS port for UDP) and which others are open which have to be protected.
# This could even be more optimised by resolving name->number and just
# protecting ports > 1023. I know it looks ... weird ... but it works! ;-)
# XXX !!!
auto_protect_tcp()
{
    PROTECT_GLOBAL=`$NETSTAT -an | \
      $GREP -E '^tcp .* 0.0.0.0:[1-9].*LISTEN|^tcp .* :::[1-9].*LISTEN' | \
      $AWK '{print $4}' | $SED 's/.*://'`
    for IP in $DEV_EXT; do
        PROTECT_EXT="$PROTECT_EXT `$NETSTAT -an | \
	 $AWK '/^tcp .* '"$IP"':[1-9].*LISTEN/ {print $4}' | $SED 's/.*://'`"
    done
    for IP in $DEV_DMZ; do
        PROTECT_DMZ="$PROTECT_DMZ `$NETSTAT -an | \
	 $AWK '/^tcp .* '"$IP"':[1-9].*LISTEN/ {print $4}' | $SED 's/.*://'`"
    done
   test "$FW_PROTECT_FROM_INTERNAL" = no || {
    for IP in $DEV_INT; do
        PROTECT_INT="$PROTECT_INT `$NETSTAT -an | \
	 $AWK '/^tcp .* '"$IP"':[1-9].*LISTEN/ {print $4}' | $SED 's/.*://'`"
    done
    export PROTECT_INT PROTECT_GLOBAL
### XXX TODO BAK
    PROTECT=`for S in $PROTECT_INT $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_INT=`echo "$FW_SERVICES_INT_TCP" | $SED 's/ /|/g'`
    PROTECT_INT=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_INT"`
    for PORT in $PROTECT_INT; do
	$LDAC $IPTABLES -A input_int -j LOG ${LOG}"-INint-DROP " -p tcp --dport $PORT --syn
	$IPTABLES -A input_int -j "$DROP" -p tcp --dport $PORT --syn
    done
   }
    PROTECT=`for S in $PROTECT_DMZ $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_DMZ=`echo "$FW_SERVICES_DMZ_TCP" | $SED 's/ /|/g'`
    PROTECT_DMZ=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_DMZ"`
    for PORT in $PROTECT_DMZ; do
	$LDAC $IPTABLES -A input_dmz -j LOG ${LOG}"-INdmz-DROP " -p tcp --dport $PORT --syn
	$IPTABLES -A input_dmz -j "$DROP" -p tcp --dport $PORT --syn
    done
    PROTECT=`for S in $PROTECT_EXT $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_EXT=`echo "$FW_SERVICES_EXT_TCP" | $SED 's/ /|/g'`
    PROTECT_EXT=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_EXT"`
    for PORT in $PROTECT_EXT; do
	$LDAC $IPTABLES -A input_ext -j LOG ${LOG}"-INext-DROP " -p tcp --dport $PORT --syn
	$IPTABLES -A input_ext -j "$DROP" -p tcp --dport $PORT --syn
    done
}

allow_tcp_highports()
{
    local j chain
    for j in $FW_ALLOW_INCOMING_HIGHPORTS_TCP; do
	case "$j" in
	[Dd][Nn][Ss]) warning "FW_ALLOW_INCOMING_HIGHPORTS_TCP=DNS no longer supported" ;;
	no) ;;
	yes)
	    for chain in input_int input_dmz input_ext; do
		$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-HiTCP " -p tcp --dport 1024: --syn
		$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-HiTCP " -p tcp --dport 1024:
		$IPTABLES -A $chain -j "$ACCEPT" -p tcp --dport 1024:
	    done
	    break;
	    ;;
	*)
	    for chain in input_int input_dmz input_ext; do
		$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-HIGH " -p tcp --sport $j --dport 1024: --syn
		$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-HIGH " -p tcp --sport $j --dport 1024:
		$IPTABLES -A $chain -j "$ACCEPT" -p tcp --sport $j --dport 1024:
	    done
	    ;;
	esac
    done
}

allow_rpc_services()
{
    local chain="input_$1"
    shift
    rpcservicerules $* | while read ARG; do
	$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-RPC " -m state --state NEW $ARG
	$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-RPC " $ARG
	$IPTABLES -A $chain -j "$ACCEPT" $ARG
    done
}

allow_ip_services()
{
    local iptables
    local chain="input_$1"
    shift
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	for PROTO in $*; do
	    $LAA $iptables -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-IP " -p $PROTO
	    $iptables -A $chain -j "$ACCEPT" -p $PROTO
	done
    done
}

allow_tcp_services()
{
    local port
    local iptables
    local chain="input_$1"
    shift
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	for port in $*; do
	    $LAC $iptables -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-TCP " -p tcp --dport $port --syn
	    $LAA $iptables -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-TCP " -p tcp --dport $port
	    $iptables -A $chain -j "$ACCEPT" -p tcp --dport $port
	done
    done
}

# UDP Stuff
allow_udp_services()
{
    local port
    local iptables
    local chain="input_$1"
    shift
    for iptables in "$IPTABLES" "$IP6TABLES"; do
	for port in $*; do
	    $LAA $iptables -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-UDP " -p udp --dport $port
	    $iptables -A $chain -j "$ACCEPT" -p udp --dport $port
	done
    done
}

# description of the code below: see TCP notes for the autoprotect feature
# XXX !!!
auto_protect_udp()
{
    PROTECT_GLOBAL=`$NETSTAT -an | \
      $GREP -E '^udp .* 0.0.0.0:[1-9]|^udp .* :::[1-9]' | $GREP -v ESTAB | \
      $AWK '{print $4}' | $SED 's/.*://'`
    for IP in $DEV_EXT; do
        PROTECT_EXT="$PROTECT_EXT `$NETSTAT -an | $GREP -v ESTAB | \
	 $AWK '/^udp .* '"$IP"':[1-9]/ {print $4}' | $SED 's/.*://'`"
    done
    for IP in $DEV_DMZ; do
        PROTECT_DMZ="$PROTECT_DMZ `$NETSTAT -an | $GREP -v ESTAB | \
	 $AWK '/^udp .* '"$IP"':[1-9]/ {print $4}' | $SED 's/.*://'`"
    done
   test "$FW_PROTECT_FROM_INTERNAL" = no || {
    for IP in $DEV_INT; do
        PROTECT_INT="$PROTECT_INT `$NETSTAT -an | $GREP -v ESTAB | \
	 $AWK '/^udp .* '"$IP"':[1-9]/ {print $4}' | $SED 's/.*://'`"
    done
    PROTECT=`for S in $PROTECT_INT $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_INT=`echo "$FW_SERVICES_INT_UDP $DNS_PORT $SQUID_PORT" | $SED 's/ /|/g'`
    PROTECT_INT=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_INT"`
    for PORT in $PROTECT_INT; do
	$LDA $IPTABLES -A input_int -j LOG ${LOG}"-INint-DROP " -p udp --dport $PORT -m state --state NEW
	$IPTABLES -A input_int -j "$DROP" -p udp --dport $PORT -m state --state NEW
    done
   }
    PROTECT=`for S in $PROTECT_DMZ $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_DMZ=`echo "$FW_SERVICES_DMZ_UDP $DNS_PORT $SQUID_PORT" | $SED 's/ /|/g'`
    PROTECT_DMZ=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_DMZ"`
    for PORT in $PROTECT_DMZ; do
	$LDA $IPTABLES -A input_dmz -j LOG ${LOG}"-INdmz-DROP " -p udp --dport $PORT -m state --state NEW
	$IPTABLES -A input_dmz -j "$DROP" -p udp --dport $PORT -m state --state NEW
    done
    PROTECT=`for S in $PROTECT_EXT $PROTECT_GLOBAL; do echo $S; done | $SORT -n`
    OPENED_EXT=`echo "$FW_SERVICES_EXT_UDP $DNS_PORT $SQUID_PORT" | $SED 's/ /|/g'`
    PROTECT_EXT=`for S in $PROTECT; do echo $S; done | $GREP -Evw "$OPENED_EXT"`
    for PORT in $PROTECT_EXT; do
	$LDA $IPTABLES -A input_ext -j LOG ${LOG}"-INext-DROP " -p udp --dport $PORT -m state --state NEW
	$IPTABLES -A input_ext -j "$DROP" -p udp --dport $PORT -m state --state NEW
    done
}

allow_highports_udp()
{
    # checking "yes" in the loop allows you to log individual services plus
    # allowing all
    for j in $FW_ALLOW_INCOMING_HIGHPORTS_UDP; do
	case "$j" in
	    [Dd][Nn][Ss])
		    warning "FW_ALLOW_INCOMING_HIGHPORTS_UDP=DNS no longer supported"
		    ;;
	    no) ;;
	    yes)
		for CHAIN in input_int input_dmz input_ext; do
		    $LAC $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-HiUDP " -m state --state NEW -p udp --dport 1024:
		    $LAA $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-HiUDP " -p udp --dport 1024:
		    $IPTABLES -A $CHAIN -j "$ACCEPT" -m state --state NEW -p udp --dport 1024:
		done
		break;
		;;
	    *)
		for CHAIN in input_int input_dmz input_ext; do
		    $LAC $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-HiUDP " -m state --state NEW -p udp --sport $j --dport 1024:
		    $LAA $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-HiUDP " -p udp --sport $j --dport 1024:
		    $IPTABLES -A $CHAIN -j "$ACCEPT" -m state --state NEW -p udp --sport $j --dport 1024:
		done
		;;
	esac
    done
}

# redirect packets from one port to another, opens ports in input_*
redirect_rules()
{
    local chain nets net1 net2 proto port1 port2
    for nets in $FW_REDIRECT; do
	IFS=, eval set -- \$nets

	net1="$1"
	net2="$2"
	proto="$3"
	port1="$4"
	port2="$5"
	
	if [ -n "$6" ]; then
	    error "Too many arguments in FW_REDIRECT -> $nets"
	elif [ -z "$net1" -o -z "$net2" -o -z "$proto" -o -z "$port1" -o -z "$port2" ]; then
	    error "Missing parameter in FW_REDIRECT -> $nets"
	elif [ "$proto" != tcp -a "$proto" != udp ]; then
	    error "FW_REDIRECT supports only tcp and udp -> $nets"
	else
	    net1=${net1/\!/\! }
	    net2=${net2/\!/\! }
	    $IPTABLES -A PREROUTING -t nat -j REDIRECT -p $proto -s $net1 -d $net2 --dport $port1 --to-ports $port2
## doesn't make sense here since drop rules are already installed
#	    for chain in input_ext input_dmz input_int; do
#		$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-REDIR " -s $net1 -p $proto --dport $port2 -m state --state NEW
#		$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-REDIR " -s $net1 -p $proto --dport $port2
#		$IPTABLES -A $chain -j "$ACCEPT" -m state --state NEW,ESTABLISHED,RELATED -p $proto -s $net1 --dport $port2
#	    done
	fi
    done
}

# parameters: zone interfaces
# assuming that only traffic from $zone interface enter the forward_$zone chain
# anyways, we don't need the -i parameter
allow_class_routing()
{
    local chain="forward_$1"
    shift
    local iface
    for iface in $*; do
	$LAA $IPTABLES -A $chain -j LOG $LOG"-`rulelog $chain`-ACC-CLASS "  -o $iface
	$IPTABLES -A $chain -j "$ACCEPT" -o $iface
    done
}

forward_icmp()
{
    local CHAIN
    for CHAIN in forward_ext forward_dmz forward_int; do
	$LAA $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-FWD-RELA "  -m state --state RELATED -p icmp --icmp-type destination-unreachable
	$LAA $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-FWD-RELA "  -m state --state ESTABLISHED,RELATED -p icmp --icmp-type echo-reply
	$IPTABLES -A $CHAIN -j "$ACCEPT" -m state --state RELATED -p icmp --icmp-type destination-unreachable
	$IPTABLES -A $CHAIN -j "$ACCEPT" -m state --state ESTABLISHED,RELATED -p icmp --icmp-type echo-reply
    done
}

forwarding_rules()
{
    local nets net1 net2 flags more_args
    for nets in $FW_FORWARD; do
	IFS=, eval set -- \$nets

	net1="$1"
	net2="$2"
	proto="$3"
	port="$4"
	flags="$5"

	case "$flags" in
	    "") ;;
	    ipsec)
		more_args="$IPSEC_MATCH"
		;;
	    *)
		echo "Error: unsupported flag in FW_FORWARD: $flags"
		net1=""
		;;
	esac

	if [ -n "$proto" ] && ! check_proto_port "$proto" "$port" "FW_FORWARD"; then
	    net1=""
	fi

	if [ -n "$net1" -a -n "$net2" ]; then
	    for CHAIN in forward_ext forward_dmz forward_int; do
		$LAC $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-FORW "  -s $net1 -d $net2 $proto $port -m state --state NEW $more_args
		$LAA $IPTABLES -A $CHAIN -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-FORW "  -s $net1 -d $net2 $proto $port $more_args
		$IPTABLES -A $CHAIN -j "$ACCEPT" -m state --state NEW,ESTABLISHED,RELATED -s $net1 -d $net2 $proto $port $more_args
	    done
	fi
     done
}

masquerading_rules()
{
    local nets net1 net2 proto port dev chain snet2 sport
    for nets in $FW_MASQ_NETS; do
	IFS=, eval set -- \$nets

	net1="$1"
	net2="$2"
	proto="$3"
	port="$4"
	sport="$port"

	if [ -n "$5" ]; then
   	    error "Too many arguments in FW_MASQ_NETS -> $nets"
	elif [ -z "$net1" ]; then
	    error "source network must not be empty in FW_MASQ_NETS -> $nets"
	elif [ -z "$proto" -a -z "$port" ] || check_proto_port "$proto" "$port" 'FW_MASQ_NETS'; then
	    net1=${net1/\!/\! }
	    net2=${net2/\!/\! }
	    snet2=""
	    if [ -n "$net2" ]; then
		snet2="-s $net2"
		net2="-d $net2"
	    fi
	    if [ -n "$port" ]; then
		sport="--sport $sport"
	    else
		sport=""
	    fi

	    for dev in $FW_MASQ_DEV; do
		for chain in forward_ext forward_dmz forward_int; do
		    $LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-MASQ "  -s $net1 $net2 $proto $port -o $dev
		    $IPTABLES -A $chain -j "$ACCEPT" -m state --state NEW,ESTABLISHED,RELATED -s $net1 $net2 $proto $port -o $dev
		    # we need to allow the replies as well
		    $LAA $IPTABLES -A $chain -d $net1 $snet2 $proto $sport -i $dev -j LOG ${LOG}"-`rulelog $CHAIN`-ACC-MASQ " -m state --state ESTABLISHED,RELATED
		    $IPTABLES -A $chain -d $net1 $snet2 $proto $sport -i $dev -j "$ACCEPT" -m state --state ESTABLISHED,RELATED
	        done
		$IPTABLES -A POSTROUTING -j MASQUERADE -t nat -s $net1 $net2 $proto $port -o $dev
	    done
	fi
    done
}

forward_masquerading_rules()
{
    local nets net1 net2 proto port1 port2 lip
    for nets in $FW_FORWARD_MASQ; do
	IFS=, eval set -- \$nets

	net1="$1"
	net2="$2"
	proto="$3"
	port1="$4"
	port2="$5"
	lip="$6"

#	test -z "$lip" && lip="$DEV_EXT"

	case "$net2" in
	    */*|'')
		error "target must be a single host in FW_FORWARD_MASQ -> $nets"
		continue
		;;
	esac

	if [ -n "$7" ]; then
   	    error "too many arguments in FW_FORWARD_MASQ -> $nets"
	elif [ -z "$net1" ]; then
	    error "source network must not be empty in FW_FORWARD_MASQ -> $nets"
        elif [ "$proto" != tcp -a "$proto" != udp ]; then
	    error "The protocol with FW_FORWARD_MASQ must be tcp or udp -> $nets"
        elif [ -z "$port1" ]; then
	    error "Port missing in FW_FORWARD_MASQ -> $nets"
	else
	    net1="-s $net1"
	    proto="-p $proto"
	    test -z "$port2" && port2="$port1"
	    port1="--dport $port1"
	    dport2="--dport $port2"
	    port2=":${port2/:/-}"
	    test -n "$lip" && lip="-d $lip"
	    for dev in $FW_MASQ_DEV; do
		$IPTABLES -A PREROUTING -j DNAT -t nat $proto $net1 $lip $port1 --to-destination ${net2}${port2} -i $dev
	    done
	    for chain in forward_ext forward_dmz forward_int; do
		$LAC $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-REVMASQ " $proto $net1 -d $net2 $dport2 -m state --state NEW
		$LAA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-ACC-REVMASQ " $proto $net1 -d $net2 $dport2
		$IPTABLES -A $chain -j "$ACCEPT" $proto $net1 -d $net2 $dport2
	    done
	fi
    done
}

# Special Logging + Deny #
drop_all()
{
    local chain
    local itype
    local chains="input_ext input_dmz input_int"

    [ "$FW_ROUTE" = yes ] && chains="$chains forward_ext forward_dmz forward_int"
    
    for chain in $chains; do
	# some packet types are considered critical
	if [ -z "$LDC" ]; then
	    $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT " -p tcp --syn
	    $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT " -p tcp --syn
	    for itype in "source-quench" "redirect" "echo-request" "timestamp-request" "address-mask-request" "2"; do
		$IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-ICMP-CRIT " -p icmp --icmp-type $itype
	    done
	    for itype in "redirect" "echo-request"; do
		$IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-ICMP-CRIT "  -p icmpv6 --icmpv6-type $itype
	    done
	    $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT " -p udp
	    $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT " -p udp
	    $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT-INV " -m state --state INVALID
	    $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT-INV " -m state --state INVALID
	fi
	# log anything else
	$LDA $IPTABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT "
	$IPTABLES -A $chain -j "$DROP"
	$LDA $IP6TABLES -A $chain -j LOG ${LOG}"-`rulelog $chain`-DROP-DEFLT "
	$IP6TABLES -A $chain -j "$DROP"
    done
}

############################################
#                                          #
# Now we begin to set the filter rules ... #
#                                          #
############################################

if [ "$ACTION" = "showlog" ]; then
    exec $PERL "$SCRIPTSDIR/SuSEfirewall2-showlog" "$@"
    die 1 "failed to execute $SCRIPTSDIR/SuSEfirewall2-showlog"
fi

###############

parse_logging

setlock

if [ "$ACTION" = "basic" ]; then
    # Reset the filter rules
    set_basic_rules

    # Setting filter rules
    # 1. allow anything which is established or related
    allow_basic_related

    # 2. allow dhcp replies from servers
    # not needed!?
    #$IPTABLES -A INPUT -j "$ACCEPT" -p udp --sport 67 -d 255.255.255.255/32 --dport 68

    # 3. allow echo requests
    $IPTABLES -A INPUT -j "$ACCEPT" -p icmp --icmp-type echo-request

    # log incoming tcp connection requests. also logging udp etc would just flood the log
    $IPTABLES -A INPUT -p tcp -m state --state NEW -j LOG $LOG"-IN-DROP-NEW-CONNECT "

    # reject anything else
    $IPTABLES -A INPUT -j "$DROP"

    die 0 "Firewall rules successfully set in simple mode"
fi

if [ "$MODE" = "test" ]; then
    DROP="ACCEPT"
    REJECT="ACCEPT"
    FW_LOG_DROP_ALL=yes
    FW_LOG_DROP_CRIT=yes
    FW_LOG_ACCEPT_ALL=no
    FW_LOG_ACCEPT_CRIT=no
    warning "SuSEfirewall2 is running in TEST MODE, no packet filtering is done!"
fi
	
if [ "$ACTION" = "stop" ]; then
    reset_rules
    handle_initscripts
    die 0 "Firewall rules unloaded."
fi

if [ "$ACTION" = "close" ]; then
    set_basic_rules
    setproc 0 /proc/sys/net/ipv4/ip_forward
    allow_basic_related
    #$IPTABLES -A INPUT -j "$ACCEPT" -p udp --sport 67 -d 255.255.255.255/32 --dport 68

    # XXX should we?
    #$IPTABLES -A INPUT -j "$ACCEPT" -p icmp --icmp-type echo-request
    die 0 "Firewall rules set to CLOSE."
fi

if [ "$ACTION" = "status" ]; then
    if [ "$UID" != 0 ]; then
	die 2 "You need to be root to check the status"
    fi
    if ! $IPTABLES -nL reject_func >/dev/null 2>&1; then
	die 1 "SuSEfirewall2 not active"
    fi
    echo
    echo "###### iptables ######"
    echo
    # yes we need cat here, while read ... does no work :-(
    for i in `sort < /proc/net/ip_tables_names`; do
	echo "### $i ###"
	$IPTABLES -t $i -vnL
	echo ""
    done
    if [ "$IP6TABLES" != ":" ]; then
	echo
	echo "###### ip6tables ######"
	echo
	for i in `sort /proc/net/ip6_tables_names`; do
	    echo "### $i ###"
	    $IP6TABLES -t $i -vnL
	    echo ""
	done
    fi
    die 0
fi

if [ "$ACTION" = "open" ]; then
    OPENHELPER="$SCRIPTSDIR/SuSEfirewall2-open"
    exec $PERL -w $OPENHELPER "$@"
    die 1 "failed to execute $OPENHELPER"
fi

### main mode ###

auto_detect_all_interfaces

parse_interfaces
load_customrules

check_interfaces
verify_parameters
verify_masq_nets

# Set default rules + flush
set_basic_rules

switch_on_ip_forwarding

set_proc_stuff

create_chains

# HOOK
fw_custom_before_antispoofing

antispoof_generic

# HOOK
fw_custom_after_antispoofing

protect_from_internal

parse_broadcast

drop_broadcast ext
drop_broadcast int
drop_broadcast dmz

allow_ipsec

fork_to_chains

antispoof_per_interface

allow_icmp

# HOOK
fw_custom_before_port_handling

process_trusted_nets

allow_ip_services ext $FW_SERVICES_EXT_IP
allow_ip_services int $FW_SERVICES_INT_IP
allow_ip_services dmz $FW_SERVICES_DMZ_IP

allow_tcp_services ext $FW_SERVICES_EXT_TCP
allow_tcp_services int $FW_SERVICES_INT_TCP
allow_tcp_services dmz $FW_SERVICES_DMZ_TCP

allow_rpc_services ext $FW_SERVICES_EXT_RPC
allow_rpc_services int $FW_SERVICES_INT_RPC
allow_rpc_services dmz $FW_SERVICES_DMZ_RPC

reject_or_drop_services int DROP INT
reject_or_drop_services ext DROP EXT
reject_or_drop_services dmz DROP DMZ

reject_or_drop_services int REJECT INT
reject_or_drop_services ext REJECT EXT
reject_or_drop_services dmz REJECT DMZ

if [ "$FW_AUTOPROTECT_SERVICES" != no ]; then
    auto_protect_tcp
fi

allow_tcp_highports

allow_udp_services ext $FW_SERVICES_EXT_UDP
allow_udp_services int $FW_SERVICES_INT_UDP
allow_udp_services dmz $FW_SERVICES_DMZ_UDP

if [ "$FW_AUTOPROTECT_SERVICES" != no ]; then
    auto_protect_tcp
fi

allow_highports_udp

# HOOK
fw_custom_before_masq

redirect_rules

if [ "$FW_ROUTE" = yes ]; then

    forward_icmp

    if [ "$FW_ALLOW_CLASS_ROUTING" = yes ]; then
	allow_class_routing int $FW_DEV_INT
	allow_class_routing ext $FW_DEV_EXT
	allow_class_routing dmz $FW_DEV_DMZ
    fi

    forwarding_rules

    if [ "$FW_MASQUERADE" = yes ]; then
	masquerading_rules
	forward_masquerading_rules
    fi
fi

# HOOK
fw_custom_before_denyall

drop_all

finish_chains

# Optimisation Rules
apply_tos_settings

[ -n "$USE_IPTABLES_BATCH" ] && commit_iptables_batch

# HTB settings
[ -n "$FW_HTB_TUNE_DEV" ] && do_qdisc_settings

handle_initscripts

# END #
die 0 "Firewall rules successfully set from $FWCONFIG"

# vim: sw=4
